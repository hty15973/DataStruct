# DataStructure


## 4.c

### ISSUE : 연결리스트의 시작

#### 연결리스트란?

연결리스트는 노드로 이루어져있다.
노드의 구성은 기본적으로 2가지로 나누어진다. 
> 1.해당 노드에 대한 데이터

> 2.인접 노드에 대한 정보를 얻을 수가 있는 노드포인터 , 일종의 표지판과 같은 역활을하며 이를 따라가면 근처의
  노드에 접근 할 수가 있다.
  
#### Node의 구성

노드의 형식은 struct Node 이며 typedef를이용해 Node라고 alias 해주었다.

```
typedef struct Node {
	int data;
	struct Node* next;
} Node;
Node* head;
```

#### 연결리스트의 참조법

##### 종료조건

> 이 코드에서는 데이터를 노드에 담고 그 노드를 기존의 노드들의 묶음의 뒤에다가 붙이는 식의 코딩을 하였다.
시작은 Node *형의 head변수로 부터 시작하며 그 이후의 노드들을 참조하기 위해 
현재위치를 나타내는 Node * 형의 cur 변수를 만들어주었다.
cur변수의 시작 위치는 head 이며 
```
cur = cur -> next;
```
> 위와 같은 형식으로 참조해서 들어간다.

> 이 연결리스트의 끝을 감지하기 위한 조건으로
```
cur -> next == NULL
```
이 TRUE로 밝혀 지면 연결리스트의 끝에 도달했음을 판단한다.

#### 데이터의 추가.

> - 데이터를 인수로받아 리스트의 끝에다가 데이터를 집어넣는 함수를 만들도록 한다. 앞서말한 연결리스트의 끝에 도달함을 판단할수있는 코드를 짠후 새로운 노드를 할당하여 이전의 끝의 노드의 next에 연결시켜주고 새로운 노드의 next에는 NULL을 data에는 받은 데이터값을 할당하여 준다.

>	> ##### 잡기술 : malloc을 이용하여 노드를 할당한다면 data와 next의 값에 쓰레기 값이 들어가게 된다. 하지만 
```
Node* node = calloc(1,sizeof(Node)
```
>	>로 선언을 해준다면 next값에다가 0이들어가서 NULL역활을 하게 되므로 따로 next에 NULL처리를 해주지않아도 되게되고 1줄을 아끼게된다
 ##### 문제점
 
 > - ###### 코드의 이원화
 >	>	listAdd함수에서 보다시피 코드에 분기점이 생기게 된다. 그이유는 리스트에 자료의 개수가 0개일때에는 스택영역의 head를 끌어와 연결하지만 1개라도 존재한다면 heap영역의 노드를 끌어와서 연결하기 때문이다.
따라서 해당함수가 이원화 되지않고 한 함수에서 두가지경우를 모두 처리할수 있게 코드를 개조할 필요가 있어보인다.

## 5.c

### ISSUE : listAdd(int data)함수에서의 이원화의 통일

#### 문제점 분석
>  데이터를 추가할때 2가지 경우가 발생한다.
>	> 1. 리스트에 자료가 0개일경우 ==> stack영역의 head의 next에다가 heap 영역의 Node를 추가하게 된다.
>	> 2. 리스트에 자료가 0개 이상 일경우 ==> heap 영역의 Node의 next에다가 heap 영역의 Node를 추가하게 된다.

#### 해결 방안
> head를 heap 영역으로 끌어올리도록하자 (더미헤드를 삽입하도록 하자)

>따라서 해당코드를 메인 문에 삽입하였다(이를 통해 만들어지는 heap영역의 노드를 더미헤드라고 한다)

```
head = calloc(1, sizeof(Node)); 
```

> 그리고

```
if (head == NULL) {
		head = node;
		return 0;
}
```

> 를 삭제해준다 == > 문제점 해결

#### 문제점

> 자료구조의 초기화를 사용자가 나서서 해주고 있다. (main문에서의 head calloc)
이를 함수화 시켜서 사용자가 내부구조를 몰라도 초기화 해서 사용할수 있도록 하고싶다.

## 6.c

### ISSUE : 자료구조의 초기화를 사용자에게 시키지말자.

#### 문제점 분석 
> 메인문에서 사용자가 직접 연결리스트의 초기값을 설정하고 있다. 
우리는 그 역활을 뺏어와서 자료구조 스스로 해당역활을 수행하도록 하자.

#### 해결방안 
> 해당기능 만을 추출하여 함수화 시키도록 한다 . 따라서 사용자는 해당함수의 스펙을 자세히 모르고 그냥 호출하여 사용하기만 하게 한다.(은닉)

#### 문제점
>해당 코드는 여전히 크나큰 문제를 가지고 있다.
바로 연결리스트의 끝지점을 판단하는데 NULL을 가지고 판단하고 있기 때문이다 . 이것이 문제가 되는 이유는 
사용자가 실수로 끝지점의 next에 접근하게 된다면 해당 라이브러리를 사용하고 있던 사용자의 프로그램이 다운 되는 영향이 일어날 가능성이 다분하다. 따라서 NULL이 아닌 다른 기준으로 연결리스트의 끝을 판단하는것이 좋아 보인다.

## 7.c

### ISSUE : 리스트의 끝지점을 NULL로 판단함으로써 시스템 붕괴의 위험이 있다.

#### 문제점 분석 
> 끝 지점을 NULL의 여부로 판단함으로써 위험이 존재한다. 따라서 다른 기준을 가지는것이 좋아보인다.

#### 해결방안

> 끝지점의 next를 참조해도 NULL이 아닌 다른값이 나오도록 새로운 값을 할당할 필요가 있는것 같다. 
우리가 더미헤드를 넣었듯이 끝에도 더미테일을 넣자.
그리고 리스트의 끝을 판별하기위해서 tail노드의 next는 자기 자신을 참조하도록 하여서 리스트의 어느 지점을 참조하여도 
NULL값을 참조하지 못하도록 한다.


#### 문제점

> 문제를 해결하기 위해 더미헤드와 더미테일을 넣은것은 좋았다. 하지만 삭제시에 더미가 아닌 노드들은 모두 삭제되었지만
더미 헤드와 테일은 삭제되지않아 메모리 누수를 발생시키고 있다.
이를 해결하기위해 마무리 함수를 추가해 주어야할것같다.

## 8.c

#### ISSUE : 리스트 삭제시에 더미헤드와 더미테일이 남게된다. =>연결리스트 반복사용시 메모리누수로 프로그램다운이 우려된다.

#### 문제점 분석 

> 다른 노드들과 다른 더미라는 성질으로 인해 삭제시에 두노드는 일반화가 되지않고 따로 처리해주어야 한다.

#### 데이터의 삭제

> 데이터의 삭제를 위해서는 삭제할 노드를 지칭하는 노드를 새로 할당하도록 한다.
그리고 head->next == tail이 될때까지 그사이의 노드를 계속 삭제하게 한다.
즉, 해당 코드가 완성된다

```
while (head->next != tail) {
		Node* node = head->next;
		head->next = node->next;
		
		free(node);
	}
```
그리고 모든 노드가 삭제된뒤에 더미 노드를 삭제하도록 한다.
```
free(head->next);
	free(head);
	head = NULL;
	tail = NULL;
```

 > listDisplay함수의 listFinalize 호출이후 호출에 대비하여 안전하게 head와 tail모두에 NULL값을 할당하도록 한다.
 ==> 추후 안전성보장
 
## 9.c
 
