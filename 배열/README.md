# ARRAY

## 1.c

### ISSUE : 배열의 기초

```
int arr[5] = {1,2,3,4,5};
```
위의 배열의 시작주소는 100이라고 가정한다

> - 배열의 이름은 곧 그 배열의 시작주소이다 즉 배열의[0]번째 방의 시작주소와 같다는 것이다

> - 배열의 한방의 크기는 담고있는 자료의 형태의 크기와 같다.

> - n번째 방을 참조하는 방법은 arr[n]도 있지만 첨자로 참조하여 *(arr+n)으로 참조하는 방법도 있다. (주소는 'arr+n'으로 참조가능 )

> - 위의 배열에서 arr + 1을 하면 arr은 배열의 이름 = 배열주소 즉 101이라고 오해할수가 있으나 앞에 sizeof(자료형)이 생략되어있다.
```
int address = arr + sizeof(*arr) * i //주소 참조법.
```

> - 웬만하면 배열명은 시작주소로 계산되어 arr[0]번째방이 참조 되어지지만 예외의 경우가 있다.
```
int size = sizeof(arr) // 4*1 = 4 (x)      4*5 =20 (o)
```

#### 배열의 한계
> 배열은 다음과 같은 한계점을 가지고 있다.

>	> 1. 배열의 크기(길이) 정보가 없음
>	> 2. 배열의 범위를 넘어설 경우를 알 수 없음
>	> 3. 배열의 크기를 조절할 수 없음

## 2.c

### ISSUE : 정수형의 자료를 저장하는 배열 만들기

#### 기본구조 

```
int arr[5];
int size = 5;
int count;
```

> - int arr[5]는 말그대로 방크기가 5개인 배열이다.
> - int size = 5 는 배열의 크기가 5개라는뜻이 된다. size를 추가한 이유는 배열에 원소를 추가할때 현재 원소의 갯수랑 비교해서 
추가적인 원소의 유입을 막기위함이다.
> - int count 는 count는 default 값이 0이 되며 데이터가 추가될때마다 1씩 늘어난다. count는 곧 배열에 들어있는 자료의 개수가 된다.
또한 size와의 비교연산에도 사용할목적으로 사용된다. 즉
> > 1. 현재 배열에 들어있는 자료수

> > 2. size와의 비교대상 으로 정의 된다.

#### 메커니즘

```
int arrayAdd(int data) {
	// 배열이 가득 찼는지를 조사
	if (count == size)
		return -1;
	arr[count++] = data;
	return 0;
}
```
> count == size를 이용해 방이 꽉찼는지 확인후 

> count번지 방의 주소에 접근하여 데이터를 집어넣는다.

#### 문제점 

> 두개이상의 배열을 선언할시에는 같은 함수로 모든배열을 컨트롤 하지 못한다.

## 3.c

### ISSUE : 단하나의 메서드를 가지고 여러개의 배열을 컨트롤하기.

#### 문제점 분석 

> - 두개이상의 배열을 선언할 시에는 그 개수에 맞게 컨트롤할수있는 함수를 1:1로 선언해주어야 한다. 우리의 목적은 단하나의 함수로 여러개의 함수를 컨트롤할수가 있는 코드를 구현하는 것이다. 

#### 문제 해결방안

> - 이와 같은 상황이 발생한 이유는 심볼들이 모두 전역으로 선언 되었기 때문이다 . 
> - 이 심볼들을 지역심볼들로 변환한다면 문제점이 해결될 것이다.

##### 수정 전 코드
```
int arrayAdd(int data);
void arrayDisplay();
```

##### 수정 후 코드

```
int arrayAdd(int arr[], int size, int * count,int data);
void arrayDisplay(int arr[],int size,int * count)
```

그리고 전역 심볼들을 모두 날려 버렸다.

#### 문제점 

> - 지역변수로 전환함에 따라서 함수의 인자가 많아 지저분해 보인다. 이를 정리할필요가 있어보인다.
