# DataStructure


## 4.c

### ISSUE : 연결리스트의 시작

#### 연결리스트란?

연결리스트는 노드로 이루어져있다.
노드의 구성은 기본적으로 2가지로 나누어진다. 
> 1.해당 노드에 대한 데이터

> 2.인접 노드에 대한 정보를 얻을 수가 있는 노드포인터 , 일종의 표지판과 같은 역활을하며 이를 따라가면 근처의
  노드에 접근 할 수가 있다.
  
#### Node의 구성

노드의 형식은 struct Node 이며 typedef를이용해 Node라고 alias 해주었다.

```
typedef struct Node {
	int data;
	struct Node* next;
} Node;
Node* head;
```

#### 연결리스트의 참조법

##### 종료조건

> 이 코드에서는 데이터를 노드에 담고 그 노드를 기존의 노드들의 묶음의 뒤에다가 붙이는 식의 코딩을 하였다.
시작은 Node *형의 head변수로 부터 시작하며 그 이후의 노드들을 참조하기 위해 
현재위치를 나타내는 Node * 형의 cur 변수를 만들어주었다.
cur변수의 시작 위치는 head 이며 
```
cur = cur -> next;
```
> 위와 같은 형식으로 참조해서 들어간다.

> 이 연결리스트의 끝을 감지하기 위한 조건으로
```
cur -> next == NULL
```
이 TRUE로 밝혀 지면 연결리스트의 끝에 도달했음을 판단한다.

#### 데이터의 추가.

> - 데이터를 인수로받아 리스트의 끝에다가 데이터를 집어넣는 함수를 만들도록 한다. 앞서말한 연결리스트의 끝에 도달함을 판단할수있는 코드를 짠후 새로운 노드를 할당하여 이전의 끝의 노드의 next에 연결시켜주고 새로운 노드의 next에는 NULL을 data에는 받은 데이터값을 할당하여 준다.

>	> ##### 잡기술 : malloc을 이용하여 노드를 할당한다면 data와 next의 값에 쓰레기 값이 들어가게 된다. 하지만 
```
Node* node = calloc(1,sizeof(Node)
```
>	>로 선언을 해준다면 next값에다가 0이들어가서 NULL역활을 하게 되므로 따로 next에 NULL처리를 해주지않아도 되게되고 1줄을 아끼게된다
 ##### 문제점
 
 > - ###### 코드의 이원화
 >	>	listAdd함수에서 보다시피 코드에 분기점이 생기게 된다. 그이유는 리스트에 자료의 개수가 0개일때에는 스택영역의 head를 끌어와 연결하지만 1개라도 존재한다면 heap영역의 노드를 끌어와서 연결하기 때문이다.
따라서 해당함수가 이원화 되지않고 한 함수에서 두가지경우를 모두 처리할수 있게 코드를 개조할 필요가 있어보인다.

## 5.c

### ISSUE : listAdd(int data)함수에서의 이원화의 통일

#### 문제점 분석
>  데이터를 추가할때 2가지 경우가 발생한다.
>	> 1. 리스트에 자료가 0개일경우 ==> stack영역의 head의 next에다가 heap 영역의 Node를 추가하게 된다.
>	> 2. 리스트에 자료가 0개 이상 일경우 ==> heap 영역의 Node의 next에다가 heap 영역의 Node를 추가하게 된다.

#### 해결 방안
> head를 heap 영역으로 끌어올리도록하자 (더미헤드를 삽입하도록 하자)

>따라서 해당코드를 메인 문에 삽입하였다(이를 통해 만들어지는 heap영역의 노드를 더미헤드라고 한다)

```
head = calloc(1, sizeof(Node)); 
```

> 그리고

```
if (head == NULL) {
		head = node;
		return 0;
}
```

> 를 삭제해준다 == > 문제점 해결

#### 문제점

> 자료구조의 초기화를 사용자가 나서서 해주고 있다. (main문에서의 head calloc)
이를 함수화 시켜서 사용자가 내부구조를 몰라도 초기화 해서 사용할수 있도록 하고싶다.

## 6.c

### ISSUE : 자료구조의 초기화를 사용자에게 시키지말자.

#### 문제점 분석 
> 메인문에서 사용자가 직접 연결리스트의 초기값을 설정하고 있다. 
우리는 그 역활을 뺏어와서 자료구조 스스로 해당역활을 수행하도록 하자.

#### 해결방안 
> 해당기능 만을 추출하여 함수화 시키도록 한다 . 따라서 사용자는 해당함수의 스펙을 자세히 모르고 그냥 호출하여 사용하기만 하게 한다.(은닉)

#### 문제점
>해당 코드는 여전히 크나큰 문제를 가지고 있다.
바로 연결리스트의 끝지점을 판단하는데 NULL을 가지고 판단하고 있기 때문이다 . 이것이 문제가 되는 이유는 
사용자가 실수로 끝지점의 next에 접근하게 된다면 해당 라이브러리를 사용하고 있던 사용자의 프로그램이 다운 되는 영향이 일어날 가능성이 다분하다. 따라서 NULL이 아닌 다른 기준으로 연결리스트의 끝을 판단하는것이 좋아 보인다.

## 7.c

### ISSUE : 리스트의 끝지점을 NULL로 판단함으로써 시스템 붕괴의 위험이 있다.

#### 문제점 분석 
> 끝 지점을 NULL의 여부로 판단함으로써 위험이 존재한다. 따라서 다른 기준을 가지는것이 좋아보인다.

#### 해결방안

> 끝지점의 next를 참조해도 NULL이 아닌 다른값이 나오도록 새로운 값을 할당할 필요가 있는것 같다. 
우리가 더미헤드를 넣었듯이 끝에도 더미테일을 넣자.
그리고 리스트의 끝을 판별하기위해서 tail노드의 next는 자기 자신을 참조하도록 하여서 리스트의 어느 지점을 참조하여도 
NULL값을 참조하지 못하도록 한다.


#### 문제점

> 문제를 해결하기 위해 더미헤드와 더미테일을 넣은것은 좋았다. 하지만 삭제시에 더미가 아닌 노드들은 모두 삭제되었지만
더미 헤드와 테일은 삭제되지않아 메모리 누수를 발생시키고 있다.
이를 해결하기위해 마무리 함수를 추가해 주어야할것같다.

## 8.c

#### ISSUE : 리스트 삭제시에 더미헤드와 더미테일이 남게된다. =>연결리스트 반복사용시 메모리누수로 프로그램다운이 우려된다.

#### 문제점 분석 

> 다른 노드들과 다른 더미라는 성질으로 인해 삭제시에 두노드는 일반화가 되지않고 따로 처리해주어야 한다.

#### 데이터의 삭제

> 데이터의 삭제를 위해서는 삭제할 노드를 지칭하는 노드를 새로 할당하도록 한다.
그리고 head->next == tail이 될때까지 그사이의 노드를 계속 삭제하게 한다.
즉, 해당 코드가 완성된다

```
while (head->next != tail) {
		Node* node = head->next;
		head->next = node->next;
		
		free(node);
	}
```
그리고 모든 노드가 삭제된뒤에 더미 노드를 삭제하도록 한다.
```
free(head->next);
	free(head);
	head = NULL;
	tail = NULL;
```

 > listDisplay함수의 listFinalize 호출이후 호출에 대비하여 안전하게 head와 tail모두에 NULL값을 할당하도록 한다.
 ==> 추후 안전성보장
 
## 9.c
 
### ISSUE : 입력한 값을 수정할 수 있는 함수를 만들자

#### 참고

> - 변경하기 전의 데이터를 변수에 담아 함수바깥으로 던져 준다. 
그렇게 함으로 써 사용자는 데이터를 받아낼수 있고 이 데이터의 처분을 결정할수가 있다.

## a.c

### ISSUE : 중간에 값을 끼워넣을수 있는 함수를 넣자

#### 참고 

> - head 에서부터 index번 반복문을 돌려 node->next를 찾은후 그 사이에 새로 노드를 할당한 후 끼워넣는다

> - index는 배열과 같이 0번지에서 부터 시작한다.

## b.c

### ISSUE : 입력받은 인덱스에 해당하는 방의 데이터 값을 읽어 오자.

## c.c

### ISSUE : 입력받은 인덱스에 해당하는 노드를 지우고 연결하자.

## d.c

### ISSUE : 전역변수로 head와 tail을 선언하여 사용 하고있다. 이를 숨기도록 하자.

#### 문제점 분석

> - 기존의 코드에서는 head와 tail count변수가 모두 전역으로 선언되어 사용되고 있습니다. 이를 숨기기위해 다음과 같은 구조체를 만들 도록 합니다
```
typedef struct List {
	Node* head, *tail;
	int count;
} List;
```
메인 함수에서는 List 형태의 변수를 선언해주고 연결리스트를 참조하는 모든 함수들에게는 List* 형 변수를 받도록 인자를 추가해 줍니다.

## e.c

### ISSUE : 잘 정리된 라이브러리지만 정수형 자료만 받을 수가 있다.

#### 문제점 분석

> - 이전의 코드는 잘 짜여진 코드지만 int 형의 자료만 받을수가 있어서 실제로는 사용할수가 없습니다.

#### 해결 방안

> - 모든 자료형을 받을수가 있또록 int data 대신 void* data 를 선언해줍니다

> - 우리가 예시로 받을 자료형은 다음과 같은 구조체 입니다.
```
typedef struct {
	char name[32];
	int age;
} Person;
```

> - 다음과 같은 구조체를 표현하기위해 우리는 display 함수를 수정할 필요가 있습니다. 먼저 함수포인터형식을 인자로 받도록 추가합니다. 이곳에 들어오는 함수포인터의 기능에 따라 출력형식이 달라질것 입니다. 위식의 테스트 코드에서 함수포인터는 다음과 같습니다
```
const char* toString(const void* ptr) {
	const Person* person = ptr;

	static char buf[32];
	sprintf(buf, "%s(%d)", person->name, person->age);
	return (const char*)buf;
}
```
display의 인자는 다음과 같이 바뀝니다
```
void listDisplay(const List* list, const char*(toString)(const void*))
```

## f.c 

### ISSUE : 사용자는 내부의 구조를 모르므로 동적할당이 된경우 메모리 누수가 일어날수가 있다.

#### 문제 분석

> - 사용자는 list의 내부 구조를 모르므로 연결리스트의 사용을 중지하게 될때 리스트에 동적할당된 메모리가 있을 수 있으므로 메모리 누수가 일어날 가능성이 있다. 

#### 해결 방안 

> - 리스트를 사용자에게 던져주어 사용자의 판단에 맞게 리스트를 처분하도록 마무리함수에서 리스트를 던져주는것이 좋을것 같다

```
List* listFinalize(List* list)
.
.
.
return list
```

