# 트리

## 트리란

> - 트리는 해쉬맵과 같은 비선형 자료이다. 한 노드에서 여러개의 가지를 가질수는 있지만 빠른자료의 탐색과 관리를 위해 left와 right라는 오직 두개의 가지들을 가지는것이 기본이며, 최선이다.

> - 주로 노드를 기준으로 노드의 데이터보다 작은것을 왼쪽으로, 노드의 데이터보다 큰것을 우측으로 보낸다. 

> - 모든것의 시초가 되는 최상위의 노드를 root라고 한다.

## 0.c

### ISSUE 트리를 생성하고 그곳에 데이터 삽입하게 bstInsert함수를 구현하도록 한다.

> - node를 생성하고 값을 할당한다음 노드의 데이터값과 기존노드의 데이터값을 비교한후 대소를 계속 비교하여 들어가야할 위치를 찾아 넣는다.
만약 값이 같다면 그것은 중복된 값이므로 버리도록 합니다.
```
while (cur != NULL) {
		parent = cur;
		if (data < cur->data)
			cur = cur->left;
		else if (data > cur->data)
			cur = cur->right;
		else {
			free(node);
			return -1;
		}
	}
```

#### 트리의 순회(검색)법에는 다음과 같은 3가지 순회 법이있다.

> - 1.전위순회 - > 노드 -> 왼쪽- >오른쪽
==> 하지만 전위순회는 별다른 특징이 없다.
추가된 순서를 나타내지않는다

> - 2.중위 순회 ->왼쪽 ->노드-> 오른쪽
==> 중위 순회는 오름차순으로 정렬된 결과가 나타나게 된다.

> - 3.후위 순회 ->왼쪽->오른쪽->노드
==> 후위 순회의 순서는  노드를 삭제할 순서이다, 즉 바닥에서부터 지워올라가는 구조이다.



## 1.c

## ISSUE : 선형이 아닌 트리 형태로 출력이 가능하게 bstDisplay함수를 구현하자

### 함수 구현법

> - 쉽게 출력하기 위해서 한변의 길이가 입력받은 데이터의 개수이상의 숫자인 정사각형 배열을 만든다.
그리고 그배열에 노드의 데이터를 삽입하는 보조함수 fillArray함수를 설계한다.
한줄씩내려올때마다 부모와 자식의 순서가 바뀐다 그러므로 fillarray함수를 호출할때에는 row를 1씩늘려준다.
또한 col값은 줄어드는 경우가없으므로 하나의 값을 입력하면 ++해주도록 한다.
```
static void fillArray(int(*arr)[10], int* row, int* col, Node* node) {
	if (node == NULL)
		return;
	++(*row);
	fillArray(arr, row, col, node->left);
	arr[*row][(*col)++] = node->data;
	fillArray(arr, row, col, node->right);
	--(*row);
```

```
void bstDisplay() {
	int arr[10][10] = { 0, };
	int row = -1, col = 0;

	system("cls");
	fillArray(arr, &row, &col, root);
}
```
## 2.c

### ISSUE : 데이터값을 입력하면 트리 내부에 그값이 있는지 확인해주는 함수 bstGet함수를 구현하자.

> - 앞에서 말한 display함수에서 노드를 놓을곳을 찾는것과 같은 알고리즘을 사용한다.
node의 data값이 기존노드의 데이터값보다 작으면 left로 탐색을,크면 right로 탐색을 계속 진행한다.

## 3.c 

### ISSUE : 원하는 데이터값을 삭제하는 함수 bstRemove함수를 구현하도록 한다.

> - 데이터값을 입력 받았다면 앞의 경우와 같이 해당 데이터값을 가지고 있는 노드로 이동을 한다. 그곳에서 새끼 노드의
유무에 따라 3가지 상황으로 나뉜다.

>- 아마 상위 노드를 지칭하는 parent node가 필요할것이다 왜냐하면 우리는 삭제를하며 해당노드를 free해주고 나갈텐데 부모노드는 여전히 지워버린노드를 가리키고 있을것이므로 메모리침범으로 죽어버릴것이다. 따라서 부모노드의 연결부분에도 null을 박아두고 나와야한다.

#### REMOVE시의 3가지 상황

1. 삭제될 노드가 단말노드인 경우 ==> 즉 left와 right에 아무런 새끼노드도 존재하지않을때이다 이때에는 아무것도 신경쓸필요없이 해당노드에 NULL을 박아두고 부모노드와의 연결부분에도 null을 박아주고 나와야한다.

2. 삭제될 노드가 1개의 새끼노드를 가지고 있을경우 ==> 해당노드가 삭제되면 새끼노드만 덩그러니 남게된다. 조부모 노드에서 아들 노드와의 연결을 끊어버리고 손자노드에 연결해주고 해당노드를 지워주면된다.

3. 삭제될 노드가 2개의 새끼노드를 가지고 있을 경우 ==> 후보노드를 찾아서 그중 적합한것을 대입해준다. 여기서 후보노드란 left와 right 새끼노드 둘다를 말한다. 좌측을 선택하거나 우측을 선택하나 자유이나 주로 우측의 노드를 선택하여 연결해준다. 그리고 선택받지 못한 후보노드는 
새 부모노드의 새끼가 된다.


## 4.c (변경사항 없음)


## 총평

### 해당코드의 단점

> - 전역변수로 되어 있어 한개의 트리구조만 사용할수있다 -> 두개이상의 알고리즘을 적용할수 있게 바꾸어보자

> - int형의 데이터만 사용할수가 있다. --> 제너릭을 하자

최악의 경우 균형이 맞춰지지 않아 리스트와 같은형식이 되는 경우가 있다. 이를 고치기위해 다음과 같은 
해결방안이 있다.

1.AVL Tree  // 속도가 느리다는 단점이 있다.
2.RB Tree

다음에는 레드블랙 트리에 대
---------------------------------------------------------------------------
레드 블랙트리는 red와 black 즉 색깔로 균형을 맞추곤 한다.
모든노드는 빨강또는 검저이다.
레드 블랙트리 조건

1. 새로운 노드는 빨강이다.
2. 루트 노드는 검정이다.
추가된 노드의 부모가 빨강이면 조부모와 부모의 색을
바꾸고 부모를 기준으로 조부모를 회전
3. 부모와 삼촌 노드가 빨강이면 조부모의 색과
바꾼다.

검정이 두개붙어있는것은 용납가능하지마나 빨강이 2개이상붙어있는걸 가만두지않는다.

-----------------------------------------------------------------------------

비트 맵 연산자

- 8 개의 LED에 대하여 상태정보를 저장하는 코드를 생각해 봅시다.

5.c 

이 코드는 메모리낭비가 심하다는 단점이 있습니다. 그래서 char 형을 써봤지만 그래도 여전히
메모리 낭비가 심합니다.

따라서 8개의 led의 상태를 표현하기위해 char leds = 0 하나로 처리하도록 합니다.

6.c

